// Auto-generated by Fontes Widget Viewer extension
// This file sets up the preview binding for widget test visualization

import 'dart:async';

import 'package:flutter_test/flutter_test.dart';
import 'package:preview_binding/preview_binding.dart';

// Track if we're in preview mode
bool _previewEnabled = false;
PreviewTestBinding? _binding;

/// This function is called by Flutter's test framework before running tests.
/// It allows us to set up the preview binding.
Future<void> testExecutable(FutureOr<void> Function() testMain) async {
  // Only enable preview when ENABLE_PREVIEW dart-define is true
  const enablePreview =
      bool.fromEnvironment('ENABLE_PREVIEW', defaultValue: false);

  if (enablePreview) {
    _previewEnabled = true;

    // IMPORTANT: Initialize the binding BEFORE testMain() is called.
    // This ensures our PreviewTestBinding is used instead of the default one.
    _binding = PreviewTestBinding.ensureInitialized();

    // Start the gRPC server for frame streaming
    await _binding!.startServer();

    // Wait for the viewer to connect before running tests
    // This ensures all frames are captured during test execution
    await _binding!.waitForViewerConnection();

    print('PREVIEW_TESTS_STARTING');

    // Register a tearDownAll that keeps the process alive until frames are delivered
    tearDownAll(() async {
      if (_previewEnabled && _binding != null) {
        final framesSent = _binding!.framesSent;
        print('PREVIEW_TESTS_COMPLETE:frames=$framesSent');

        // Brief delay to ensure frames are delivered before server shutdown.
        // With on-pump-only capture, we have few frames so 1 second is enough.
        const drainDuration = Duration(seconds: 1);
        print('PREVIEW_DRAINING:${drainDuration.inSeconds}s');
        await Future.delayed(drainDuration);

        print('PREVIEW_DRAIN_COMPLETE');
        await _binding!.stopServer();
      }
    });

    // Now run the actual tests - they will use our PreviewTestBinding
    // NOTE: testMain() only REGISTERS tests, it doesn't execute them.
    // Tests run AFTER testExecutable returns, along with tearDownAll.
    await testMain();
  } else {
    // Normal test execution without preview
    await testMain();
  }
}
